Занятие №2. Простой HTTP сервер для REST API

* .gitignore - файл в котором перечислены файлы и каталоги проекта, на которые гит не должен обращать внимания - не предлагать их добавить в индекс

* JSON - формат представленния объектов в JavaScript. Поддерживается во многих языках программирования "из коробки". В C++ в виде библиотек.

* REST-сервис - HTTP сервер с ендпоинтами в виде существительных: /user, /meeting. И данными в JSON

* Методы HTTP-запросов и их применение в REST-сервисах:
  - GET - чтение
  - POST - создание
  - PATCH - редактирование
  - DELETE - удаление

* Коды ответа HTTP
  - от 200 до 299 успех
  - от 400 до 499 ошибка в запросе
  - от 500 до 599 внутренняя ошибка сервиса
  - и другие коды

* OpenAPI (swagger) - спецификация для описания интерфейса REST-сервиса. [Наш OpenAPI](https://app.swaggerhub.com/apis-docs/azcol/meetup/1.0.0)

* Как тестировать REST с помощью curl
  - curl -X GET http://127.0.0.1:8080/user/meeting - список встреч
  - curl -X POST -d '{"name": "Лекция 3"}' 127.0.0.1:8080/user/meeting - создание встречи
  - curl -X PATCH -d '{"name": "Лекция 3", "description": "Поговорим о перзистенси"}' http://127.0.0.1:8080/user/meeting/1
  - curl -X DELETE -d http://127.0.0.1:8080/user/meeting/1 - удаление встречи

* Полиморфизм в C++ на примере программы:
```C++
#include <iostream>
class A {
public:
    A() {}
    virtual void B() const {
        std::cout << "A::B()" << std::endl;
    }
};

class C : public A {
public:
    void B() const override {
        std::cout << "B::B()" << std::endl;
    }
};

void UseByReferenceA(const A &a) {
    a.B();
}

void UseByValueA(A a) {
    a.B();
}

int main() {
    C c;
    UseByReferenceA(c); // выведет B::B()
    UseByValueA(c); // A::B() так как виртульные методы задействуются 
                    // только для указателей и ссылок
}
```

* Паттерн проектирования "фабрика". Фабрика создает другие объекты по каким-то параметрам. В нашем случае по объекту request - возвращает объекты handler для обработки запроса.

* Паттерн проектирования "синглтон". Синглтон - единственный экземпляр класса на всю программу. Реализовали его простейшим способом - статическая переменная внутри функции.

* Интерфейс Storage для создания различных хранилищ объектов встреч. Узнали что обязательно в базовом классе с виртуальными методами должен быть виртуальный деструктор, чтоб корректно удалялись объекты дочерних классов. Пример:
```C++
#include <iostream>
class A {
public:
    A() {}
    virtual void B() const {
        std::cout << "A::B()" << std::endl;
    }
    ~A() {
        std::cout << "~A()" << std::endl;
    }
};

class C : public A {
public:
    void B() const override {
        std::cout << "B::B()" << std::endl;
    }
    ~C() {
        std::cout << "~C()" << std::endl;
    }
};

int main() {
    A *a = new C();;
    delete a;
} // Выведет ~A() но не выведет ~C()
```

* Реализация MapStorage - хранилище встреч в оперативной памяти. Хранится до тех пор пока сервер запущен. Когда сервер перезапустится, тогда и данные пропадут

* Критерии оценки ДЗ - прогоняем тесты, считаем процент прошедших и перекладываем на десятибалльную шкалу. 

* Плюс можно получить дополнительный балл за своевременный и качественно сделанный pull-request. 
  - Своевременно - вечером накануне следующего занятия должно быть готово, что б мы успели почитать дома.
  - Качественно - следуйте нашим соглашениям по именованию на [wiki](https://github.com/460s/meeting_backend/wiki). Правильно форматируйте код как в .clang-format описано (ctrl-shift-i для vs code). Используйте понятные имена переменных методов и функций, избегайте сложной логики и длинных методов и т.д. "Совершенный код" Макконнелла (и подобные книги) вам в помощь

* Не стесняйтесь спрашивать, что непонятно, это нормально что у вас не получается - курс сложный и короткий.

* Домашнее задание: Точно так же как на занятии все храним просто в оперативной памяти в мапе, нужно реализовать для сервера методы:
  - PATCH /user/meeting/{id}
  - GET /user/meeting/{id}
  - DELETE /user/meeting/{id}
